## Kotlin 协程
协程把异步编程放入库中来简化这类操作。程序逻辑在协程中顺序表述，而底层的库会将其转换为异步操作

### 阻塞VS挂起

- 协程可以被挂起而且无需阻塞线程，线程阻塞代价非常高，尤其在高负载时，因为只有相对少量线程实际可用，因此阻塞其中一个会导致一些重要的任务被延迟。

- 协程挂起几乎是无代价的。不需要上下文切换或者 OS 的任何其他干预。最重要的是，挂起可以在很大程度上由用户库控制

- 协程不能在随机的指令中挂起，而只能在所谓的挂起点挂起，这会调用特别标记的函数。

### 挂起函数
调用标记有特殊修饰符 suspend 的函数时，会发生挂起：
```
suspend fun doSomething(foo: Foo): Bar {
    ……
}
```

挂起函数能够以与普通函数相同的方式获取参数和返回值，但它们**只能从协程、其他挂起函数以及内联到其中的函数字面值中调用**。

`await()` 可以是一个挂起函数（因此也可以在一个 `async {}` 块中调用）

```
async {
    ……
    val result = computation.await()
    ……
}

```
挂起函数 `await()` 与 `doSomething()` 不能在没有内联到挂起函数体的函数字面值以及像 `main()`这样的普通函数中调用

```
fun main(args: Array<String>) {
    doSomething() // 错误：挂起函数从非协程上下文调用
    
    async { 
        ...
        computations.forEach { // `forEach` 是一个内联函数，该 lambda 表达式是内联的
            it.await() // OK
}
            
        thread { // `thread` 不是内联函数，所以该 lambda 表达式并非内联的
            doSomething() // 错误
        }
    }
}
```

挂起函数可以是虚拟的，当被覆盖时，必须指定`suspend`修饰符


调用suspend方法的详细流程是:
在协程里, 如果调用了一个suspend方法, 协程就会挂起, 释放自己的执行权, 但在协程挂起之前, suspend方法内部一般会启动了另一个线程或协程, 我们暂且称之为"分支执行流"吧, 它的目的是运算得到一个数据.
当suspend方法里的*分支执行流"完成后, 就会调用系统API重新恢复协程的执行, 同时会数据返回给协程(如果有的话).


> 协程创建后, 并不总是立即执行, 要分是怎么创建的协程, 通过`launch`方法的第二个参数是一个枚举类型`CoroutineStart`, 如果不填, 默认值是`DEFAULT`, 那么久协程创建后立即启动, 如果传入`LAZY`, 创建后就不会立即启动, 直到调用`Job`的`start`方法才会启动.

**suspend方法并不总是引起协程挂起**, 只有其内部的数据未准备好时才会.

### @RestrictsSuspension 注解

` @RestrictsSuspension `用于要阻止用户添加新方式来挂起协程


### async/await模式:

async方法作用和launch方法基本一样, 创建一个协程并立即启动, 但是**async创建的协程可以携带返回值**.
`launch`方法的返回值类型是`Job`, `async`方法的返回值类型是`Deferred`,是`Job`的子类, `Deferred`里有个`await`方法, 调用它可得到协程的**返回值**.






