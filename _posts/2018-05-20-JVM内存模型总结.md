## JVM内存模型总结

JVM内存模型：
![jvm](https://img-blog.csdn.net/20150720152805765?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

### 堆
堆是Java虚拟机管理内存中**最大**的一块内存区域，堆是线程间共享内存的区域，堆里面主要存放**对象实例以及数组**，堆的大小通过-Xms和-Xmx指定最小和最大，当堆空余内存空间不足40%，JVM就会增大内存到指定的-Xmx大小，大于70%就会减小到-Xms，为了防止频繁跳转heap大小，通常设为一样。
堆内存=新生代+旧生代+持久代，当GC时候，将内存分成**新生代：旧生代=2：1**，新生代由Eden+survior1+survior2=8:1:1,新生代采用coping算法回收，在GC时通常保留一个survior来存放存活的对象，GC主要发生在其他两个区域。当对象存活时长超过一定的年龄（默认15）就会把它放入老生代，大的对象直接进入老生代，老生代采用mark-sweep算法回收

### 方法区
方法区也称为“永生代”，用来存储**类的加载信息，常量，静态变量**，是各个线程的共享内存区域。永久代的垃圾收集是和老年代(old generation)捆绑在一起的，因此无论谁满了，都会触发永久代和老年代的垃圾收集。
运行时常量池：类除了版本，字段，方法，接口等基本信息之外，还有一个常量池，用于存放编译器生成的符号引用，在类加载阶段>链接阶段>准备阶段，将符号引用转换为直接引用。类加载后放到运行时的常量池中

### 虚拟机栈
描述的是**java方法执行的内存模型**，每一个方法执行的时候都会产生一个**栈帧**，用于存放局部变量表、操作栈、动态链接、方法出口等信息。
栈帧可以理解为动画一帧一帧执行，那么JVM方法也是一帧一帧执行的，只不过没帧里面放的是局部变量表和操作栈等信息。**每个方法从调用到完成，就是一个栈帧从虚拟机栈中入栈到出栈的过程**

### 本地方法栈
与虚拟机栈类似，不同是该栈是为native方法服务
### 程序计数器
是最小的一块内存区域，它是**当前线程执行字节码的行号指示器**,字节码解释器的工作就是改变计数器的值来选取下一条指令执行，分支、循环、异常处理、线程恢复等基础功能都需要依赖计数器完成。
### 直接内存
直接内存并不是虚拟机内存的一部分，也不是Java虚拟机规范中定义的内存区域。jdk1.4中新加入的NIO，引入了通道与缓冲区的IO方式，它可以调用Native方法直接分配堆外内存，这个堆外内存就是本机内存，不会影响到堆内存的大小.

